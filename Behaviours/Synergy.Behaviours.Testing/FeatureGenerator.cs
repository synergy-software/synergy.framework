using System.Runtime.CompilerServices;
using System.Text;
using System.Text.RegularExpressions;

namespace Synergy.Behaviours.Testing;

public static class FeatureGenerator
{
    // TODO: Marcin Celej [from: Marcin Celej on: 03-05-2023]: Add way to generate non-fluent implementation of the methods
    
    public static void Generate<TBehaviour>(
        this TBehaviour feature,
        string from,
        string to,
        string[]? include = null,
        string[]? exclude = null,
        [CallerFilePath] string callerFilePath = ""
    )
    {
        var code = feature.Generate(from, include, exclude, callerFilePath);
        var destinationFilePath = Path.Combine(Path.GetDirectoryName(callerFilePath), to);
        File.WriteAllText(destinationFilePath, code.ToString());
    }

    public static string Generate<TBehaviour>(
        this TBehaviour featureClass,
        string from,
        string[]? include = null,
        string[]? exclude = null,
        [CallerFilePath] string callerFilePath = ""
    )
    {
        if (featureClass == null)
            throw new ArgumentNullException(nameof(featureClass));

        StringBuilder code = new StringBuilder();
        string className = featureClass.GetType()
                                       .Name;
        var gherkinPath = Path.Combine(Path.GetDirectoryName(callerFilePath), from);

        string[] gherkins = FeatureGenerator.ReadAllLinesFrom(gherkinPath);

        code.AppendLine("// <auto-generated />");
        code.AppendLine("using System.CodeDom.Compiler;");
        code.AppendLine();
        code.AppendLine($"namespace {featureClass.GetType().Namespace};");
        code.AppendLine();
        code.AppendLine(
            $"[GeneratedCode(\"{typeof(FeatureGenerator).Assembly.FullName}\", \"{typeof(FeatureGenerator).Assembly.GetName().Version.ToString()}\")]");
        code.AppendLine($"public partial class {className}");
        code.AppendLine("{");

        string? scenarioMethod = null;
        bool includeScenario = ResetInclude();
        List<string>? tags = null;
        int lineNo = 0;
        string? backgroundMethod = null;
        string? backgroundStarted = null;
        string? featureName = null;
        string? ruleName = null;

        foreach (var line in gherkins)
        {
            lineNo++;

            var comment = Regex.Match(line, "\\s*#(.*)");
            if (comment.Success)
            {
                tags = null;
                includeScenario = ResetInclude();
                //code.AppendLine(line.Replace("#", "//"));
                continue;
            }

            if (string.IsNullOrWhiteSpace(line))
            {
                tags = null;
                includeScenario = ResetInclude();

                continue;
            }

            var feature = Regex.Match(line, "\\s*Feature\\: (.*)");
            if (feature.Success)
            {
                featureName = feature.Groups[1]
                                     .Value;
                continue;
            }

            var rule = Regex.Match(line, "\\s*Rule\\: (.*)");
            if (rule.Success)
            {
                CloseBackground();
                CloseScenario();

                ruleName = rule.Groups[1]
                               .Value;

                code.AppendLine($"    // {line.Trim()}");
                code.AppendLine();

                continue;
            }

            var background = Regex.Match(line, "\\s*Background\\:");
            if (background.Success)
            {
                CloseScenario();

                backgroundMethod = FeatureGenerator.ToMethod(ruleName ?? featureName ?? "Feature") + "Background";
                backgroundStarted = backgroundMethod;
                code.AppendLine($"    private {className} {backgroundMethod}() // {line.Trim()}");
                code.Append($"        => ");
                continue;
            }

            var outline = Regex.Match(line, "\\s*Scenario (Outline|Template)\\: (.*)");
            if (outline.Success)
            {
                throw new NotSupportedException($"Scenario Outline keyword is not supported\nLine {lineNo}: {line.Trim()}");
            }

            var example = Regex.Match(line, "\\s*(Examples|Scenarios)\\: (.*)");
            if (example.Success)
            {
                throw new NotSupportedException($"Examples keyword is not supported\nLine {lineNo}: {line.Trim()}");
            }

            if (line.Trim()
                    .StartsWith("@"))
            {
                CloseScenario();

                tags = Regex.Matches(line, "\\@\\w+")
                            .Select(m => m.Value)
                            .ToList();

                if (include != null)
                    includeScenario = tags.Intersect(include)
                                          .Any();

                if (exclude != null)
                    includeScenario = !tags.Intersect(exclude)
                                           .Any();

                // if (include)
                //     code.AppendLine($"    [Xunit.Trait({string.Join(", ", tags.Select(t => "\"" + t.TrimStart('@') + "\""))})]");
                continue;
            }

            if (includeScenario == false && backgroundStarted == null)
                continue;

            var scenario = Regex.Match(line, "\\s*Scenario\\: (.*)");
            if (scenario.Success)
            {
                CloseBackground();
                CloseScenario();

                scenarioMethod = FeatureGenerator.ToMethod(scenario.Groups[1]
                                                                   .Value);
                code.AppendLine("    [Xunit.Fact]");
                if (tags != null)
                    code.AppendLine($"    // {String.Join(" ", tags)}");
                code.AppendLine($"    public void {scenarioMethod}() // {line.Trim()}");
                code.Append($"        => {nameof(Feature<object>.Background)}()");
                if (backgroundMethod == null)
                    code.AppendLine();
                else
                {
                    code.AppendLine($".{backgroundMethod}()");
                }

                continue;
            }

            var given = Regex.Match(line, "\\s*Given (.*)");
            if (given.Success)
            {
                if (backgroundStarted == null)
                {
                    code.Append($"               .");
                }
                else
                {
                    code.Append($"     ");
                }

                code.AppendLine($"{nameof(Feature<object>.Given)}().{FeatureGenerator.ToMethod(given.Groups[1].Value)}()  // {line.Trim()}");
                continue;
            }

            var and = Regex.Match(line, "\\s*And (.*)");
            if (and.Success)
            {
                code.AppendLine($"                 .{nameof(Feature<object>.And)}().{FeatureGenerator.ToMethod(and.Groups[1].Value)}()  // {line.Trim()}");
                continue;
            }

            var asterisk = Regex.Match(line, "\\s*\\* (.*)");
            if (asterisk.Success)
            {
                code.AppendLine($"                 .{nameof(Feature<object>.And)}().{FeatureGenerator.ToMethod(asterisk.Groups[1].Value)}()  // {line.Trim()}");
                continue;
            }

            var but = Regex.Match(line, "\\s*But (.*)");
            if (but.Success)
            {
                code.AppendLine($"                 .{nameof(Feature<object>.But)}().{FeatureGenerator.ToMethod(but.Groups[1].Value)}()  // {line.Trim()}");
                continue;
            }

            var when = Regex.Match(line, "\\s*When (.*)");
            if (when.Success)
            {
                code.AppendLine($"                .{nameof(Feature<object>.When)}().{FeatureGenerator.ToMethod(when.Groups[1].Value)}()  // {line.Trim()}");
                continue;
            }

            var then = Regex.Match(line, "\\s*Then (.*)");
            if (then.Success)
            {
                code.AppendLine($"                .{nameof(Feature<object>.Then)}().{FeatureGenerator.ToMethod(then.Groups[1].Value)}() // {line.Trim()}");
                continue;
            }
        }

        CloseBackground();
        CloseScenario();

        code.AppendLine("}");

        return code.ToString();

        void CloseScenario()
        {
            if (scenarioMethod != null)
            {
                code.AppendLine($"            .Moreover().After{scenarioMethod}();");
                code.AppendLine();
                code.AppendLine(
                    $"    partial void After{scenarioMethod}(" +
                    // "[CallerMemberName] string callerMemberName = \"\", " +
                    // "[CallerFilePath] string callerFilePath = \"\"" +
                    ");"
                );

                code.AppendLine();
            }

            scenarioMethod = null;
        }

        void CloseBackground()
        {
            if (backgroundStarted != null)
            {
                code.AppendLine($"            ;");
                code.AppendLine();
            }

            backgroundStarted = null;
        }

        bool ResetInclude()
        {
            if (include != null)
                return false;

            if (exclude != null)
                return true;

            return true;
        }
    }

    private static string[] ReadAllLinesFrom(string gherkinPath)
    {
        if (File.Exists(gherkinPath))
            return File.ReadAllLines(gherkinPath);

        var gherkins = new[]
        {
            $"Feature: {Path.GetFileNameWithoutExtension(gherkinPath)}",
            "",
            "# TODO: Provide scenarios here, check the sample down here",
            "",
            "#  Scenario: There can be only one",
            "#    Given there are 3 ninjas",
            "#    And there are more than one ninja alive",
            "#    When Two ninjas meet, they will fight",
            "#    Then one ninja dies (but not me)",
            "#    And there is one ninja less alive",
        };

        using var stream = File.CreateText(gherkinPath);
        foreach (string line in gherkins)
        {
            stream.WriteLine(line);
        }

        stream.Close();

        return gherkins;
    }

    private static string ToMethod(string sentence)
    {
        var parts = sentence.Split(" ");
        var m = string.Concat(parts.Where(p => !string.IsNullOrEmpty(p))
                                   .Select(p => p.Substring(0, 1)
                                                 .ToUpperInvariant() + p.Substring(1)));
        m = Regex.Replace(m, "[^A-Za-z0-9_]", "");
        return m;
    }

    // private static string[]? ReadTagsFrom(string line)
    // {
    //     if (line.TrimStart().StartsWith("@") == false)
    //         return null;
    //
    //     return Regex.Match(line, "\\@\\w+")
    //                 .Groups.Values.Select(g => g.Value)
    //                 .ToArray();
    // }

    private static bool StartsWithAny(this string line, params string[] starts)
    {
        foreach (string start in starts)
        {
            if (line.StartsWith(start, StringComparison.InvariantCultureIgnoreCase))
                return true;
        }

        return false;
    }
}